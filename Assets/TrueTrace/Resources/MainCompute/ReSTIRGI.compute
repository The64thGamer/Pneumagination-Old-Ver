#include "../GlobalDefines.cginc"
#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#include "Materials.cginc"

#ifdef HDRP
    Texture2DArray<float2> MotionVectors;
#else
    Texture2D<float2> MotionVectors;
#endif

inline Ray CreateCameraRayGI(float2 uv, uint pixel_index, float4x4 CamToWorldMat, float4x4 CamInvProjMat) {
    float3 origin = mul(CamToWorldMat, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    float3 direction = mul(CamInvProjMat, float4(uv, 0.0f, 1.0f)).xyz;

    direction = normalize(mul(CamToWorldMat, float4(direction, 0.0f)).xyz);
    return CreateRay(origin, direction);
}


#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(Ray ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        while(true) {
            q.TraceRayInline(myAccelerationStructure, rayFlags, 0x1, myRay);
            while(q.Proceed()){}
            
            if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) {

                float u = q.CommittedTriangleBarycentrics().y;
                float v = q.CommittedTriangleBarycentrics().x;
                int2 Indexes = int2(q.CommittedInstanceID(), q.CommittedGeometryIndex());
                int triangle_id = q.CommittedPrimitiveIndex();
                #ifdef AdvancedAlphaMapped
                    int mesh_id;

                    int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                    triangle_id += triangleOffset;
                    mesh_id = MeshOffsets[Indexes.x].y;

                    int MaterialIndex = (_MeshData[mesh_id].MaterialOffset + AggTris[triangle_id].MatDat);
                    if(_Materials[MaterialIndex].MatType == CutoutIndex) {
                        float2 BaseUv = AggTris[triangle_id].tex0 * (1.0f - u - v) + AggTris[triangle_id].texedge1 * u + AggTris[triangle_id].texedge2 * v;
                        float2 Uv = AlignUV(BaseUv, _Materials[MaterialIndex].AlbedoTexScale, _Materials[MaterialIndex].AlbedoTex);
                        if(_TextureAtlas.SampleLevel(my_point_clamp_sampler, Uv, 0).w < 0.1f) {myRay.TMin = q.CommittedRayT() + 0.001f; continue;}
                    }
                #endif

                return false;
            }
            return true;
        }
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}

#pragma kernel ReSTIRGIKernel

float4x4 PrevCamToWorld;
float4x4 PrevCamInvProj;

float3 CamDelta;
bool AbandonSamples;
bool UseReSTIRGITemporal;
bool UseReSTIRGISpatial;
bool DoReSTIRGIConnectionValidation;
int ReSTIRGISpatialCount;
int ReSTIRGITemporalMCap;
float GISpatialRadius;

inline void UpdateReservoir(inout float4 CurRes, inout float wsum, float4 PrevRes, float rndnum, inout int2 CachedID, int2 ID) {
    float w = max(PrevRes.x * PrevRes.y * PrevRes.w, 0);
    wsum += w;
    [branch]if (rndnum < (w / wsum)) {
        CachedID = ID;
        CurRes.w = PrevRes.w;
        CurRes.z = PrevRes.z;
    }
}

RWTexture2D<half2> GradientWrite;


[numthreads(12, 12, 1)]
void ReSTIRGIKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if(id.x > screen_width || id.y > screen_height) return;
    const int pixel_index = id.x + id.y * screen_width;

    float2 UV = id.xy / float2(screen_width, screen_height);
    float2 jitter = ((randomNEE(1, pixel_index) - 0.5));
    const SmallerRay CameraRay = CreateCameraRay((id.xy + (UseReCur ? 0 : 0)) / float2(screen_width, screen_height) * 2.0f - 1.0f, pixel_index);

    bool ActuallyRender = (TempAlbedoTex[id.xy].w > 0) && !AbandonSamples;
    
    const float4 GBuffer = ScreenSpaceInfoRead[id.xy];
    const float3 GeomNorm = i_octahedral_32(asuint(GBuffer.x));
    const float3 SurfNorm = i_octahedral_32(asuint(GBuffer.y));
    const float3x3 NormTangentSpace = GetTangentSpace2(GeomNorm);
    const float3x3 NormTangentSpaceSurf = GetTangentSpace2(SurfNorm);
    uint4 Target = PrimaryTriData[id.xy];
    MyMeshDataCompacted Mesh = _MeshData[Target.x];
    Target.y += Mesh.TriOffset;
    float2 TriUV;
    TriUV.x = asfloat(Target.z);//(Target.z & 0xffff) / 65535.0f;
    TriUV.y = asfloat(Target.w);//(Target.z >> 16) / 65535.0f;
    float4x4 Inverse = inverse(Mesh.Transform);
    float3 PrimaryHitPosition = mul(Inverse, float4(AggTris[Target.y].pos0 + TriUV.x * AggTris[Target.y].posedge1 + TriUV.y * AggTris[Target.y].posedge2,1)).xyz;

    ColData CenterCol = GlobalColors[pixel_index];

    CenterCol.throughput.x = pixel_index;
    CenterCol.throughput.y = frames_accumulated;
    uint4 WorldPos = WorldPosC[id.xy];
    float4 NEEPos = NEEPosC[id.xy];

    MaterialData SurfaceMat = _Materials[(asuint(GBuffer.w) << 2) >> 2];
    float3 Surf = unpackRGBE(WorldPos.w);
    SurfaceMat.surfaceColor = unpackRGBE(WorldPos.w);
    SurfaceMat.roughness = (asuint(CenterCol.pad) & 0xFFFF) / 65535.0f;
    SurfaceMat.metallic = (asuint(CenterCol.pad) >> 16) / 65535.0f;

    uint Case = asuint(ScreenSpaceInfoRead[id.xy].w) >> 30;
    float3 bsdf, NEEbsdf;
    float pdf, NEEpdf;
    CenterCol.Indirect = clamp(CenterCol.Indirect, 0.0f, 250.0f);//I NEED to find a better way of handling fireflies
    CenterCol.Direct = clamp(CenterCol.Direct, 0.0f, 250.0f);//I NEED to find a better way of handling fireflies
    CenterCol.PrimaryNEERay = packRGBE(clamp(unpackRGBE(CenterCol.PrimaryNEERay),0.0f, 250.0f));//I NEED to find a better way of handling fireflies
    CenterCol.PrimaryNEERay *= EvaluateBsdf(SurfaceMat, CameraRay.direction, normalize(NEEPos.xyz - PrimaryHitPosition), GeomNorm, NEEpdf, NEEbsdf, pixel_index);
    bool Valid2 = ReconstructBsdf(SurfaceMat, CameraRay.direction, normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition), GeomNorm, pdf, bsdf, NormTangentSpace, pixel_index, Case);
    float Lum = luminance(Valid2 * (CenterCol.Direct + CenterCol.Indirect) * bsdf) + luminance(unpackRGBE(CenterCol.PrimaryNEERay) * NEEbsdf);
    float4 CurrentRes = {0,0,Case,clamp(Lum, 0, 3000)};

    #ifdef HDRP
        float2 MotionVector = MotionVectors[int3(UV * float2(TargetWidth, TargetHeight),0)].xy;
    #else
        float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, UV, 0).xy;
    #endif

    uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
    float4 PrevRes = ReservoirB[prevIndex];

    int2 CachedID = -1;
    GradientWrite[ceil(id.xy / 3)] = 0;
    [branch]if(ActuallyRender) {
            GlobalColors[pixel_index].Direct = 0;
            GlobalColors[pixel_index].Indirect = 0;
        // }
            GlobalColors[pixel_index].PrimaryNEERay = 0;
        CenterCol.throughput.z = asfloat(GBuffer.y);
        bool SkipTemporal = false;
        if(ReSTIRGIUpdateRate != 0) {
            if(RandomNums[id.xy].z != 0 && Case != 3) {
                if(NEEPosB[prevIndex].w != 0 || NEEPos.w != 0) GradientWrite[ceil(id.xy / 3)] = clamp(pow(abs(NEEPos.w - NEEPosB[prevIndex].w) / max(NEEPosB[prevIndex].w, NEEPos.w),1.0f),0,1);
                if(abs(NEEPosB[prevIndex].w - NEEPos.w) > 0.1f * max(max(NEEPosB[prevIndex].w, NEEPos.w),1.1f)) {
                    CenterCol.PrimaryNEERay = 0;
                    CenterCol.Direct = 0;
                    CenterCol.Indirect = 0;
                    NEEPos.w = 0;
                    CurrentRes.x = 1;
                    CurrentRes.y = 0;
                    CenterCol.throughput.x = 0;
                } else {
                    float depth_prev = PrevScreenSpaceInfo[prevIndex].z;
                    float3 geo_normal_prev = i_octahedral_32(asuint(PrevScreenSpaceInfo[prevIndex].x));//needs to be TEX_PT_GEO_NORMAL_B, but since for now I am not worrying about normal maps yet, it can use the same texture
                    
                    float dist_depth = (abs(GBuffer.z - depth_prev) - length(CamDelta)) / abs(GBuffer.z);
                    float dot_geo_normals = dot(GeomNorm, geo_normal_prev);

                    if ((dist_depth < 0.1f && dot_geo_normals > 0.7)) {
                        CenterCol = PrevGlobalColorsA[prevIndex.x + prevIndex.y * screen_width];
                        CurrentRes = PrevRes;
                    }
                }
                SkipTemporal = true;
            }
        }
        float wsum = CurrentRes.w;

        bool SuccessfullyReprojected = SkipTemporal;
        [branch]if(!SkipTemporal) {
            if(UseReSTIRGITemporal) {
                float depth_prev = PrevScreenSpaceInfo[prevIndex].z;
                float3 geo_normal_prev = i_octahedral_32(asuint(PrevScreenSpaceInfo[prevIndex].x));//needs to be TEX_PT_GEO_NORMAL_B, but since for now I am not worrying about normal maps yet, it can use the same texture
                
                float dist_depth = (abs(GBuffer.z - depth_prev)) / abs(GBuffer.z);
                float dot_geo_normals = dot(GeomNorm, geo_normal_prev);

                if ((dist_depth < 0.1f && dot_geo_normals > 0.7)) {

                    // float4 PrevRes = ReservoirB[prevIndex];
                    PrevRes.x = clamp(PrevRes.x,1,(Case == 3) ? 12.0f : ReSTIRGITemporalMCap);
                    UpdateReservoir(CurrentRes, wsum, PrevRes, randomNEE(23, pixel_index).x, CachedID, prevIndex);
                    CurrentRes.x += PrevRes.x;
                    SuccessfullyReprojected = true;
                }
            }

            CurrentRes.x++;
            CurrentRes.y = wsum / max(CurrentRes.x * CurrentRes.w, 0.0000001f);
        }
        if(!SuccessfullyReprojected) {
            CurrentRes.x = 1;
            CurrentRes.y = 1;
        }

        if(CurrentRes.y > 10) CurrentRes.y = 0;
        if(CachedID.x != -1) {
            ColData TempCol = PrevGlobalColorsA[CachedID.x + CachedID.y * screen_width];
            uint4 TempWorldPos = WorldPosB[CachedID];
            float4 TempNEEPos = NEEPosB[CachedID];
            SurfaceMat.roughness = (asuint(TempCol.pad) & 0xFFFF) / 65535.0f;
            SurfaceMat.metallic = (asuint(TempCol.pad) >> 16) / 65535.0f;
            TempCol.PrimaryNEERay *= EvaluateBsdf(SurfaceMat, CameraRay.direction, normalize(TempNEEPos.xyz - PrimaryHitPosition), GeomNorm, NEEpdf, NEEbsdf, pixel_index);
            bool Valid4 = ReconstructBsdf(SurfaceMat, CameraRay.direction, normalize(asfloat(TempWorldPos.xyz) - PrimaryHitPosition), GeomNorm, pdf, bsdf, NormTangentSpace, pixel_index, CurrentRes.z);
            if(Valid4) {
                CenterCol = TempCol;
                float Lum = luminance((CenterCol.Direct + CenterCol.Indirect) * bsdf) + luminance(unpackRGBE(CenterCol.PrimaryNEERay) * NEEbsdf);
                CurrentRes.w = clamp(Lum,0,3000);
                WorldPos = TempWorldPos;
                NEEPos = TempNEEPos;
            }
        }

        PrevGlobalColorsB[pixel_index] = CenterCol;
        ReservoirA[id.xy] = CurrentRes;
        WorldPosA[id.xy] = WorldPos;
        NEEPosA[id.xy] = NEEPos;
        CachedID = -1;
        if (UseReSTIRGISpatial) {
            const int PrevM = CurrentRes.x;
            const float3 SelectedNorm = PrevM < 1 ? GeomNorm : SurfNorm;
            bool IsMirror = (SurfaceMat.metallic == 1 || Case == 3) && SurfaceMat.roughness < 0.01f;
            float2 neighborOffset;
            int2 NeighborIndex;
            float2 RandOffsets;
            float2 RandOffsets2;
            bool ReplaceCenter = (prevIndex.x < 0 || prevIndex.x >= (int)screen_width || prevIndex.y < 0 || prevIndex.y >= (int)screen_height);
            int2 CenterIndex = ReplaceCenter ? id.xy : prevIndex;
            for (int i = 0; i < ReSTIRGISpatialCount; i++) {
                RandOffsets = randomNEE(i + 24, pixel_index);
                RandOffsets2 = randomNEE(i + 96, pixel_index);

                neighborOffset = vogelDiskSample(i, ReSTIRGISpatialCount, RandOffsets.y, 2.0f * PI * RandOffsets.x) * RandOffsets2.x * GISpatialRadius * (IsMirror ? 0.05f : 1.0f);
                if(!IsMirror && dot(neighborOffset, neighborOffset) < 1) neighborOffset = normalize(neighborOffset) * 6.0f;
                NeighborIndex = CenterIndex + neighborOffset;

                if (!(NeighborIndex.x < 0 || NeighborIndex.x >= (int)screen_width || NeighborIndex.y < 0 || NeighborIndex.y >= (int)screen_height)) {

                    PrevRes = ReservoirB[NeighborIndex];
                    const float4 PrevGBuffer = PrevScreenSpaceInfo[NeighborIndex];

                    float NormFactor = dot(i_octahedral_32(asuint(PrevM < 1 ? PrevGBuffer.x : PrevGBuffer.y)), SelectedNorm);
                    float DistDiff = ReplaceCenter ? 0.0f : (abs(GBuffer.z - PrevGBuffer.z)) / (24.0f * dot(CamDelta,CamDelta) + 1);
                    
                    if (!(DistDiff >= 0.1f || NormFactor < 0.99) && CurrentRes.z == PrevRes.z) {
                        UpdateReservoir(CurrentRes, wsum, PrevRes, RandOffsets2.y, CachedID, NeighborIndex);
                        CurrentRes.x += PrevRes.x;
                    }
                }
            }

            CurrentRes.y = wsum / max(CurrentRes.x * CurrentRes.w, 0.0000001f);
        }

        if (CurrentRes.y > 10) CurrentRes.y = 0;
         SurfaceMat.surfaceColor =  max(Surf, 0.005f);

        if(CachedID.x != -1) {
            ColData TempCol = PrevGlobalColorsA[CachedID.x + CachedID.y * screen_width];
            uint4 TempWorldPos = WorldPosB[CachedID];
            float4 TempNEEPos = NEEPosB[CachedID];
            SurfaceMat.roughness = (asuint(TempCol.pad) & 0xFFFF) / 65535.0f;
            SurfaceMat.metallic = (asuint(TempCol.pad) >> 16) / 65535.0f;
            TempCol.PrimaryNEERay *= EvaluateBsdf(SurfaceMat, CameraRay.direction, normalize(TempNEEPos.xyz - PrimaryHitPosition), SurfNorm, NEEpdf, NEEbsdf, pixel_index);
            bool Valid4 = ReconstructBsdf(SurfaceMat, CameraRay.direction, normalize(asfloat(TempWorldPos.xyz) - PrimaryHitPosition), SurfNorm, pdf, bsdf, NormTangentSpaceSurf, pixel_index, ReservoirB[CachedID].z);
            if(Valid4 || Case == 3) {
                CenterCol = TempCol;
                WorldPos = TempWorldPos;
                NEEPos = TempNEEPos;
            } else {
                WorldPosC[id.xy] = uint4(asuint(normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition)), packRGBE(SurfaceMat.surfaceColor));
                return;
            }
        } else {
            SurfaceMat.roughness = (asuint(CenterCol.pad) & 0xFFFF) / 65535.0f;
            SurfaceMat.metallic = (asuint(CenterCol.pad) >> 16) / 65535.0f;
            bool Valid4 = ReconstructBsdf(SurfaceMat, CameraRay.direction, normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition), SurfNorm, pdf, bsdf, NormTangentSpaceSurf, pixel_index, CurrentRes.z);
            
            if(!Valid4 && Case != 3) {
                WorldPosC[id.xy] = uint4(asuint(normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition)), packRGBE(SurfaceMat.surfaceColor));
                return;
            } else {
                CenterCol.PrimaryNEERay *= EvaluateBsdf(SurfaceMat, CameraRay.direction, normalize(NEEPos.xyz - PrimaryHitPosition), SurfNorm, NEEpdf, NEEbsdf, pixel_index);
            }
        }

        if (DoReSTIRGIConnectionValidation && Case != 3) {
            PrimaryHitPosition += GeomNorm * NormalOffset;
            float Distance = length(PrimaryHitPosition - asfloat(WorldPos.xyz)) - 0.025f;
            Ray ray = CreateRay(PrimaryHitPosition, normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition));

            bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
            if (!ConnectedlyVisable) {CenterCol.Direct = 0; CenterCol.Indirect = 0; GradientWrite[id.xy] = 1;}
            #ifdef ExtraSampleValidation
                if (CenterCol.PrimaryNEERay != 0) {
                    Distance = length(PrimaryHitPosition - NEEPos.xyz) - 0.025f;
                    ray = CreateRay(PrimaryHitPosition, normalize(NEEPos.xyz - PrimaryHitPosition));

                    ConnectedlyVisable = VisabilityCheck(ray, Distance);
                    if (!ConnectedlyVisable) {
                        CenterCol.PrimaryNEERay = 0;
                        GradientWrite[id.xy] = 1;
                    }
                }
            #endif
        }

        if(Case != 3) TempAlbedoTex[id.xy] = float4( max(bsdf, 0.005f), 1);
        GlobalColors[pixel_index].Direct = CenterCol.Direct * CurrentRes.y;
        GlobalColors[pixel_index].Indirect = CenterCol.Indirect * CurrentRes.y;
        GlobalColors[pixel_index].PrimaryNEERay = packRGBE(unpackRGBE(CenterCol.PrimaryNEERay) * CurrentRes.y * NEEbsdf);
        GlobalColors[pixel_index].pad = CenterCol.pad;
        GlobalColors[pixel_index].IsSpecular = CenterCol.IsSpecular;
        WorldPosC[id.xy] = uint4(asuint(normalize(asfloat(WorldPos.xyz) - PrimaryHitPosition)), packRGBE(SurfaceMat.surfaceColor));
    } else {
        PrevGlobalColorsB[pixel_index] = CenterCol;
        ReservoirA[id.xy] = CurrentRes;
        WorldPosA[id.xy] = WorldPos;
        NEEPosA[id.xy] = NEEPos;
    }
}

