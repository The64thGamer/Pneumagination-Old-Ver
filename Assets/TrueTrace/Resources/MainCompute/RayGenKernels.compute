#include "CommonData.cginc"
#include "../GlobalDefines.cginc"
#ifndef DX11
    #pragma use_dxc
#endif

#ifdef HDRP
Texture2DArray<float2> MotionVectors;
Texture2DArray<float3> NormalTex;
Texture2DArray<float> Depth;
#else
Texture2D<float2> MotionVectors;
Texture2D<float3> NormalTex;
Texture2D<float> Depth;
#endif

#pragma kernel GenerateASVGF 

static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0};
const static RayHit tempray = CreateRayHit();

[numthreads(256, 1, 1)]
void GenerateASVGF(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    RayData globray = {Rays[pixel_index].origin, octahedral_32(Rays[pixel_index].direction), pixel_index, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
    GlobalColors[pixel_index] = InitCol;
    WorldPosA[id.xy] = float4(0,0,0, 0);
    NEEPosA[id.xy] = float4(0,0,0, 0);
    // InterlockedAdd(BufferSizes[0].tracerays, 1);

}




#pragma kernel Generate
[numthreads(256, 1, 1)]
void Generate(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    float2 jitter = ((random(1, pixel_index) - 0.5));
    float2 uv = float2((id.xy + (UseReCur ? 0 : jitter)) / float2(screen_width, screen_height) * 2.0f - 1.0f);

    SmallerRay ray = CreateCameraRay(uv, pixel_index);
    RayData globray = {ray.origin, octahedral_32(ray.direction), pixel_index, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
    GlobalColors[pixel_index] = InitCol;

    // InterlockedAdd(BufferSizes[0].tracerays, 1);
}